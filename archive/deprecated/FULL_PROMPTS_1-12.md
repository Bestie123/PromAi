# АГЕНТНАЯ СИСТЕМА РАЗРАБОТКИ - ПОЛНЫЕ ПРОМПТЫ 1-12

## КОНТЕКСТНАЯ СИСТЕМА (ОБЯЗАТЕЛЬНО ДЛЯ ВСЕХ ПРОМПТОВ)

```
[SESSION_ID] {генерируется автоматически}
[PROJECT_ID] {из project_registry.json}
[CONTEXT_STATE]
  registry: project_registry.json
  todo: todo.json  
  deps: dependencies_map.json
  log: changelog.md
[PARENT_ACTION] {ID предыдущего действия}
[AFFECTED_IDS] [{список затронутых ID}]
```

---

## ПРОМПТ 1: ИНИЦИАЛИЗАЦИЯ ПРОЕКТА

**Триггер:** Начало нового проекта  
**Зависимости:** нет  
**Следующие промпты:** ПРОМПТ 2, ПРОМПТ 3

```
[ACTION] INIT_PROJECT
[PROJECT_NAME] {название}
[TECH_STACK] {технологии}

Создай:
1. Структуру папок проекта
2. project_registry.json с PROJECT_ID
3. todo.json с начальными задачами
4. dependencies_map.json (пустой)
5. changelog.md
6. Git репозиторий

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: PROJECT_ID, базовая структура
- todo.json: TASK_001 (создать SystemRegistry), TASK_002 (создать Inspector)
- changelog.md: "Project initialized"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 2: CREATE_CORE_SYSTEM
2. ПРОМПТ 3: CREATE_INSPECTOR
```

---

## ПРОМПТ 2: СОЗДАНИЕ БАЗОВОЙ СИСТЕМЫ

**Триггер:** После ПРОМПТ 1  
**Зависимости:** INIT_PROJECT  
**Следующие промпты:** ПРОМПТ 3, ПРОМПТ 4

```
[ACTION] CREATE_CORE_SYSTEM
[PARENT_ACTION] INIT_PROJECT
[MODULES] SystemRegistry, PluginManager

Создай базовые модули:
1. MODULE_SystemRegistry_VER_1.0
   - register(), get(), getAll(), getDependencies()
   - Уникальные FUNC_ID для каждой функции
2. MODULE_PluginManager_VER_1.0  
   - loadPlugin(), unloadPlugin(), listPlugins()
   - Зависимость от SystemRegistry

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: добавить оба модуля с ID
- dependencies_map.json: связь PluginManager → SystemRegistry
- todo.json: закрыть TASK_001, создать TASK_003 (тесты)
- changelog.md: "Added core system modules"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 3: CREATE_INSPECTOR (использует SystemRegistry)
2. ПРОМПТ 4: CREATE_MODULE (любой новый модуль)
```

---


## ПРОМПТ 5: ДОБАВЛЕНИЕ ФУНКЦИИ

**Триггер:** Расширение функциональности  
**Зависимости:** зависит от модулей  
**Следующие промпты:** ПРОМПТ 6, ПРОМПТ 7

```
[ACTION] ADD_FEATURE
[PARENT_ACTION] {предыдущее действие}
[FEATURE_NAME] {название}
[DESCRIPTION] {описание функциональности}
[AFFECTED_MODULES] [{список ID модулей}]

[USE_CASES]
- {конкретный случай использования 1}
- {конкретный случай использования 2}
- {конкретный случай использования 3}

[ARCHITECTURE_REQUIREMENTS]
- {требование к архитектуре 1}
- {требование к архитектуре 2}
- {требование к архитектуре 3}

[INTEGRATION_POINTS]
- SystemRegistry для регистрации компонентов
- Event system для коммуникации
- UI точки расширения (hooks)

АНАЛИЗ ЗАВИСИМОСТЕЙ:
- Загрузи все затронутые модули из registry
- Проверь граф зависимостей
- Предложи 2-3 варианта реализации

[OUTPUT]
- Архитектура новой функции
- Базовые классы и интерфейсы
- Примеры использования
- Документация для разработчиков

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: обновить версии модулей
- dependencies_map.json: новые связи (если есть)
- todo.json: TASK для тестирования функции
- changelog.md: "Added feature: {name}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 6: CREATE_TESTS
2. ПРОМПТ 7: CODE_REVIEW
```

---

## ПРОМПТ 6: СОЗДАНИЕ ТЕСТОВ

**Триггер:** После создания/изменения кода  
**Зависимости:** тестируемый модуль  
**Следующие промпты:** ПРОМПТ 7, ПРОМПТ 8

```
[ACTION] CREATE_TESTS
[PARENT_ACTION] {действие создавшее код}
[COMPONENT_ID] {ID компонента}

[TEST_TYPES]
- Unit тесты для методов класса
- Integration тесты с зависимостями
- E2E тесты пользовательских сценариев
- Performance тесты для рендеринга

[TEST_SCENARIOS]
- Инициализация с различными данными
- Взаимодействие пользователя (клики, ховеры)
- Граничные случаи (пустые данные, ошибки)
- Интеграция с SystemRegistry

[TEST_FRAMEWORK] Jest/JSDOM (или предложи альтернативу для браузерного окружения)

ЗАГРУЗИ КОНТЕКСТ:
- Модуль из project_registry.json
- Его зависимости из dependencies_map.json

[OUTPUT]
- Полный набор тестов
- Конфигурация тестового окружения
- Скрипты запуска тестов
- Отчет о покрытии кода

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: статус тестирования модуля
- todo.json: закрыть TASK тестирования
- changelog.md: "Added tests for {component}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 7: CODE_REVIEW
2. ПРОМПТ 8: FIX_CODE (если тесты выявили проблемы)
```

---

## ПРОМПТ 8: ИСПРАВЛЕНИЕ КОДА

**Триггер:** Найдена ошибка/проблема  
**Зависимости:** проблемный модуль  
**Следующие промпты:** ПРОМПТ 6, ПРОМПТ 7

```
[ACTION] FIX_CODE
[PARENT_ACTION] {действие выявившее проблему}
[COMPONENT_ID] {ID компонента}
[ERROR_DESCRIPTION] {описание}
[ERROR_LOG] {лог ошибки}

АНАЛИЗ С INSPECTOR:
- Используй Inspector для анализа элементов
- Проверь граф зависимостей
- Найди затронутые модули

Исправь проблему:
1. Исправь код с сохранением ID
2. Обнови версию модуля (если критично)
3. Обнови/добавь тесты
4. Проверь зависимые модули

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: статус/версия модуля
- dependencies_map.json: проверить целостность
- todo.json: закрыть TASK бага, создать TASK регресс-теста
- changelog.md: "Fixed: {описание}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 6: CREATE_TESTS (регресс-тесты)
2. ПРОМПТ 7: CODE_REVIEW
```

---

## ПРОМПТ 9: РЕФАКТОРИНГ

**Триггер:** Нужно улучшить код  
**Зависимости:** рефакторимый модуль  
**Следующие промпты:** ПРОМПТ 6, ПРОМПТ 7

```
[ACTION] REFACTOR
[PARENT_ACTION] {предыдущее действие}
[TARGET_ID] {ID модуля}
[REASON] {причина рефакторинга}

АНАЛИЗ ВЛИЯНИЯ:
- Загрузи модуль и зависимости
- Найди все зависимые модули
- Предложи 2-3 варианта рефакторинга

Выполни рефакторинг:
1. Сохрани или обнови ID элементов
2. Обнови зависимости
3. Обнови тесты
4. Проверь зависимые модули

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: версия модуля
- dependencies_map.json: связи (если изменились)
- todo.json: TASK проверки зависимых модулей
- changelog.md: "Refactored: {описание}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 6: CREATE_TESTS
2. ПРОМПТ 7: CODE_REVIEW
```

---

## ПРОМПТ 10: СОЗДАНИЕ ПЛАГИНА

**Триггер:** Нужен новый плагин  
**Зависимости:** CREATE_CORE_SYSTEM  
**Следующие промпты:** ПРОМПТ 6, ПРОМПТ 7

```
[ACTION] CREATE_PLUGIN
[PARENT_ACTION] {предыдущее действие}
[PLUGIN_NAME] {название}
[PLUGIN_TYPE] UI/Data/Integration/Utility

ПРОВЕРЬ СИСТЕМУ:
- MODULE_PluginManager_VER_1.0 существует
- API совместимость

Создай плагин:
1. Файл src/plugins/{name}/plugin.js с IPlugin интерфейсом
2. Manifest.json с метаданными
3. Уникальные ID для элементов
4. Регистрация в PluginManager
5. Документация и примеры

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: новый плагин
- dependencies_map.json: связь Plugin → PluginManager
- todo.json: TASK тестирования плагина
- changelog.md: "Added plugin: {name}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 6: CREATE_TESTS
2. ПРОМПТ 7: CODE_REVIEW
```

---

## ПРОМПТ 11: ЕЖЕДНЕВНАЯ РАЗРАБОТКА

**Триггер:** Начало рабочего дня  
**Зависимости:** текущее состояние  
**Следующие промпты:** зависит от задач

```
[ACTION] DAILY_DEVELOPMENT
[PARENT_ACTION] {вчерашнее действие}
[TODAY_TASK] {основная задача}
[CURRENT_PROGRESS] {опиши что уже сделано}
[BLOCKERS] {опиши проблемы если есть}

ЗАГРУЗИ СОСТОЯНИЕ:
- project_registry.json
- todo.json (активные задачи)
- changelog.md (последние изменения)

[NEXT_STEPS]
1. {конкретный шаг с указанием модулей}
2. {добавить data-атрибуты для инспектора}
3. {интегрировать с SystemRegistry}
4. {создать тесты}

[SPECIFIC_QUESTIONS]
- Как лучше организовать архитектуру модуля?
- Какие события должны эмитироваться?
- Как интегрировать с существующими модулями?

[OUTPUT_EXPECTATION]
- Чистый код с уникальными ID
- Рабочие примеры использования
- Интеграция с главным приложением
- Обновленная документация

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- todo.json: статусы задач
- changelog.md: прогресс дня

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
- Зависят от запланированных задач
```

---

## ПРОМПТ 12: УЛУЧШЕНИЕ UX

**Триггер:** Нужно улучшить интерфейс  
**Зависимости:** UI модули  
**Следующие промпты:** ПРОМПТ 6, ПРОМПТ 7

```
[ACTION] ENHANCE_UX
[PARENT_ACTION] {предыдущее действие}
[AREA] {область улучшения}

[IMPROVEMENTS]
- WYSIWYG редактирование с реальным превью
- Горячие клавиши для частых операций
- Автосохранение с индикацией
- Конфликт-редактор для синхронизации
- Оффлайн-режим с последующей синхронизацией

[USER_STORIES]
- Как пользователь, я хочу видеть изменения в реальном времени
- Как пользователь, я хочу использовать клавиатуру для эффективной работы
- Как пользователь, я не хочу терять данные при обрыве сети

[TECHNICAL_APPROACH]
- Operational transforms для конфликт-разрешения
- Service Worker для оффлайн-работы
- Debounced auto-save
- Local-first architecture

АНАЛИЗ ТЕКУЩЕГО UX:
- Загрузи UI модули из registry
- Проанализируй пользовательские сценарии
- Определи болевые точки

[OUTPUT]
- Улучшенный код редактора
- Новая функциональность
- Тесты пользовательских сценариев
- Документация для пользователей

ОБЯЗАТЕЛЬНЫЕ ОБНОВЛЕНИЯ:
- project_registry.json: версии UI модулей
- dependencies_map.json: новые связи
- todo.json: TASK пользовательского тестирования
- changelog.md: "Enhanced UX: {описание}"

СЛЕДУЮЩИЕ ДЕЙСТВИЯ:
1. ПРОМПТ 6: CREATE_TESTS (UX сценарии)
2. ПРОМПТ 7: CODE_REVIEW
```



---

## ДОПОЛНИТЕЛЬНЫЕ ТРЕБОВАНИЯ

### Разбиение задач на шаги
- Каждый промпт должен разбивать сложные задачи на подзадачи
- Указывать временные оценки для каждого шага
- Предлагать параллельное выполнение независимых задач

### Модульность
- Все компоненты должны быть слабо связанными
- Четкие интерфейсы между модулями
- Возможность замены модулей без влияния на систему

### Система плагинов
- API для создания плагинов
- Изоляция плагинов (sandbox)
- Механизм обновления плагинов
- Документация для разработчиков плагинов

### Предложение вариантов решения
- Каждый промпт должен предлагать 2-3 варианта реализации
- Анализ плюсов и минусов каждого варианта
- Рекомендации по выбору оптимального решения
